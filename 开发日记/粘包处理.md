# 粘包的解决方案



## 问题描述

TCP的缺包粘包问题：假设客户端发送abc, def, hij, 三个数据包发送出去

1. 客户端的粘包现象：客户端因为有一个Nagle优化算法，会将这三个包合并成一个数据包发送出去，这就属于客户端的粘包现象，如果关闭Nagle优化算法，那么调用几次send就发送几次数据包，客户端的粘包问题就解决了

2. 服务器端的粘包现象：不管你客户端是否粘包，服务端都存在粘包的问题；就算客户端不粘包，服务端两次recv之间的间隔可能大于100毫秒，也可能小于100毫秒，当客户端的三个包【abcdefghij】都到了内核缓冲区时，；服务端调用一次recv，就可能拿到了全部的“abcdefghij”，这就是服务端的 粘包。

## 粘包问题的解决

总的来说，解决粘包问题，就是要把收发的数据包，拆开，严格的独立开来。

解决的方法就是给收发的数据包定义一个统一的格式【规则】：客户端和服务端都遵守这个规则，就能够解决粘包问题；

包格式：  包头 + 包体 的格式； 其中，包头  是固定的长度 【10字节】， 在包头中，有一个成员变量会记录整个包【包头 + 包体】  的长度；  这样在接收的时候就先接固定的10个字节，然后收满了以后，再根据包头中的长度信息，收取包体的长度。

收包时候可以用状态机的方式去接收。

```markdown
收包总结：
（1）先收固定长度包头 10字节；
（2）收满后，根据包头中的内容，计算出包体的长度：整个长度-10
（3）我再收包体长度这么多的数据，收完了，一个包就完整了；
我们就认为受到了一个完整的数据包；从而解决了粘包的问题；
```
   

